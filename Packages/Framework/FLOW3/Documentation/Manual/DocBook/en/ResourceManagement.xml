<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="flow3.resourcemanagement"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:ns52="http://www.w3.org/1998/Math/MathML"
         xmlns:ns5="http://www.w3.org/1999/xlink"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Resource Management</title>

  <para>Traditionally a PHP application deals directly with all kinds of
  files. Realizing a file upload is usually an excessive task because you need
  to create a proper upload form, deal with deciphering the
  <varname>$_FILES</varname> superglobal and move the uploaded file from the
  temporary location to a safer place. You also need to analyze the content
  (is it safe?), control web access and ultimately delete the file when it's
  not needed anymore.</para>

  <para>FLOW3 relieves you of this hassle and lets you deal with simple
  <classname>Resource</classname> objects instead. File uploads are handled
  automatically, enforcing the restrictions which were configured by means of
  validation rules. The publishing mechanism was designed to support a wide
  range of scenarios, starting from simple publication to the local file
  system up to fine grained access control and distribution to one or more
  content delivery networks. This all works without any further ado by you,
  the application developer.</para>

  <section>
    <title>Static Resources</title>

    <para>FLOW3 packages may provide any amount of static resources. They
    might be images, stylesheets, javascripts, templates or any other file
    which is used within the application or published to the web. Static
    resources may either be public or private:</para>

    <itemizedlist>
      <listitem>
        <para>public resources are automatically mirrored to the public web
        directory and are publicly accessible without any restrictions
        (provided you know the filename)</para>
      </listitem>

      <listitem>
        <para>private resources are not published by default. They can either
        be used internally (e.g. as templates) or published with certain
        access restrictions</para>
      </listitem>
    </itemizedlist>

    <para>Whether a static package resource is public or private is determined
    by its parent directory. For a package <package>Foo</package> the public
    resources reside in a folder called
    <filename>Foo/Resources/Public/</filename> while the private resources are
    stored in <filename>Foo/Resources/Private/</filename>. The directory
    structure below <filename>Public</filename> and
    <filename>Private</filename> is up to you and will be cloned to the web
    resources folder.</para>
  </section>

  <section>
    <title>Persistent Resources</title>

    <para>Data which was uploaded by a user or generated by your application
    is called a <emphasis>persistent resource</emphasis>. Although these
    resources are usually stored as files, they are never referred to by their
    path and filename directly but are represented by
    <classname>Resource</classname> objects.</para>

    <note>
      <para>It is important to completely ignore the fact that resources are
      stored as files somewhere in FLOW3's directory structure â€“ you should
      only deal with resource objects.</para>
    </note>

    <para>New persistent resources can be created by either importing or
    uploading a file. In either case the result is a new
    <classname>Resource</classname> object which can be attached to any other
    object. A resource exists as long as the <classname>Resource</classname>
    object is connected to another entity or value object which is persisted.
    If a resource is not attached to any other persisted object, its data will
    be permanently removed at the end of the script run.</para>
  </section>

  <section>
    <title>Importing Resources</title>

    <para>Importing resources is one way to create a new resource object. The
    <classname>ResourceManager</classname> provides a simple API method for
    this purpose:</para>

    <example>
      <title>Importing a new resource</title>

      <programlisting language="php">class ImageController {

   /**
    * @inject
    * @var \F3\FLOW3\Resource\ResourceManager
    */
   protected $resourceManager;

   // ... more code here ...

   /**
    * Imports an image
    * 
    * @param string $imagePathAndFilename
    * @return void
    */
   public function importImageAction($imagePathAndFilename) {
      $newResource = $this-&gt;resourceManager-&gt;importResource($imagePathAndFilename);
      
      $newImage = $this-&gt;objectManager-&gt;create('F3\MyPackage\Domain\Model\Image');
      $newImage-&gt;setOriginalResource($newResource);

      $this-&gt;imageRepository-&gt;add($newImage);
   }
}</programlisting>
    </example>

    <para>The <classname>ImageController</classname> in our example provides a
    method to import a new image. Because an image consists of more than just
    the image file (we need a title, caption, generate a thumbnail, ...) we
    created a whole new model representing an image. The imported resource is
    considered as the "original resource" of the image and the
    <classname>Image</classname> model could easily provide a "thumbnail
    resource" for a smaller version of the original.</para>

    <para>This is what happens in detail while executing the
    <methodname>importImageAction</methodname> method:</para>

    <procedure>
      <step>
        <para>The URI (in our case an absolute path and filename) is passed to
        the <methodname>importResource</methodname> method which analyzes the
        file found at that location.</para>
      </step>

      <step>
        <para>The file is imported into FLOW3's persistent resources storage
        using the sha1 hash over the file content as its filename. If a file
        with exactly the same content is imported it will reuse the already
        stored resource.</para>
      </step>

      <step>
        <para>The Resource Manager returns a new
        <classname>Resource</classname> object which refers to the newly
        imported file.</para>
      </step>

      <step>
        <para>A new <classname>Image</classname> object is created and the
        resource is attached to it.</para>
      </step>

      <step>
        <para>The image is added to the
        <classname>ImageRepository</classname>. Only from now on the new image
        and the related resource will be persisted. If we omitted that step,
        the image, the resource and in the end the imported file would be
        discarded at the end of the script run.</para>
      </step>
    </procedure>

    <para>In order to delete a resource just disconnect the resource object
    from the persisted object, for example by unsetting
    <property>originalResource</property> in the <classname>Image</classname>
    object.</para>
  </section>

  <section>
    <title>Resource Uploads</title>

    <para>The second way to create new resources is uploading them via a POST
    request. FLOW3's MVC framework detects incoming file uploads and
    automatically converts them into <classname>Resource</classname> objects.
    In order to persist an uploaded resource you only need to persist the
    resulting object.</para>

    <para>Consider the following Fluid template:</para>

    <programlisting language="html">&lt;f:form method="post" action="create" object="{newImage}" name="newImage" enctype="multipart/form-data"&gt;
   &lt;f:form.textbox property="image.title" value="My image title" /&gt;
   &lt;f:form.upload property="image.originalResource" /&gt;
   &lt;f:form.submit value="Submit new image"/&gt;
&lt;/f:form&gt;</programlisting>

    <para>This form allows for submitting a new image which consists of an
    image title and the image resource (e.g. a JPEG file). The following
    controller can handle the submission of the above form:</para>

    <programlisting language="php">class ImageController {

   /**
    * @inject
    * @var \F3\FLOW3\Resource\ResourceManager
    */
   protected $resourceManager;

   // ... more code here ...

   /**
    * Creates a new image
    * 
    * @param \F3\MyPacakge\Domain\Model\Image $newImage The new image
    * @return void
    */
   public function createAction(\F3\MyPacakge\Domain\Model\Image $newImage) {
      $this-&gt;imageRepository-&gt;add($newImage);
      $this-&gt;forward('index');
   }
}</programlisting>

    <para>Provided that the <classname>Image</classname> class has a
    <property>title</property> and a <property>originalResource</property>
    property and that they are accessible through
    <methodname>setTitle</methodname> and
    <methodname>setOriginalResource</methodname> respectively the above code
    will work just as expected.</para>

    <tip>
      <para>There are more API functions in FLOW3's
      <classname>ResourceManager</classname> which allow for retrieving
      additional information about the circumstances of resource uploads.
      Please refer to the API documentation for further details.</para>
    </tip>
  </section>

  <section>
    <title>Resource Publishing</title>

    <section>
      <title>Static Resources</title>

      <para>By default static resources (usually provided by packages) are
      published to the web directory on the first script run and whenever
      packages are activated or deactivated. If resource files are added,
      removed or changed after the first run, they won't be published again.
      This behavior is desired in a production context where it would be to
      time intensive to check for updated resources on every run.</para>

      <para>In a development context however, you'll gladly sacrifice some
      microseconds for the convenience of automatically updated resource
      files. This can be achieved by setting "resource: publishing:
      detectPackageResourceChanges" to yes â€“ which is already the case in the
      Development context settings in FLOW3's standard distribution.</para>

      <para>Published static resources can be used in Fluid templates via the
      built-in resource view helper:</para>

      <programlisting>&lt;img src="{f:uri.resource(path: 'Images/Icons/FooIcon.png', package: 'MyPackage')}" /&gt;</programlisting>

      <para>Note that the <parameter>package</parameter> parameter is optional
      and defaults to the package containing the currently active
      controller.</para>

      <warning>
        <para>Although it might be tempting shortcut, never refer to the
        resource files directly through a URL like
        <uri>_Resources/Static/Packages/MyPackage/Images/Icons/FooIcon.png</uri>
        because you can't really rely on this path. Always use the resource
        view helper instead.</para>
      </warning>
    </section>

    <section>
      <title>Persistent Resources</title>

      <para>Persistent resources are published on demand because FLOW3 cannot
      know which resources are meant to be public and which ones are to kept
      private. The trigger for publishing persistent resources is the
      generation of its public web URI. A very common way to do that is
      displaying a resource in a Fluid template:</para>

      <programlisting>&lt;img src="{f:uri.resource(resource: image.originalResource)}" /&gt;</programlisting>

      <para>The resource view helper (<code>f:uri.resource()</code>) will ask
      the <classname>ResourcePublisher</classname> for the web URI of the
      resource stored in <varname>image.originalResource</varname>. The
      publisher checks if the given resource has already been published and if
      not publishes it right away.</para>

      <para>A published persistent resource is accessible through a web URI
      like
      <uri>http://example.local/_Resources/Persistent/107bed85ba5e9bae0edbae879bbc2c26d72033ab.jpg</uri>.
      One advantage of using the sha1 hash of the resource content as a
      filename is that once the resource changes it gets a new filename and is
      displayed correctly regardless of the cache settings in the user's web
      browser. Search engines on the other hand prefer more meaningful
      filenames. For these cases the resource view helper allows for defining
      a speaking title for a resource URI:</para>

      <programlisting>&lt;img src="{f:uri.resource(resource: image.originalResource, title: image.title)}" /&gt;</programlisting>

      <para>A URI produced by the above template would look like this:
      <uri>http://example.local/_Resources/Persistent/107bed85ba5e9bae0edbae879bbc2c26d72033ab/my-speaking-title.jpg</uri>.</para>

      <para>You can define as many titles for each resource as you want â€“ the
      resulting file is always the same, identified by the sha1 hash.</para>
    </section>

    <section>
      <title>Mirror Mode</title>

      <para>Publishing resources basically means copying files from a private
      location to the public web directory. Creating copies however comes with
      a little speed penalty and in some cases the size of duplicated
      resources can become an issue.</para>

      <para>If your operating system supports symbolic links, you can speed up
      the publication process by telling FLOW3 to create symlinks instead of
      copies. This can be achieved through some setting in FLOW3's
      <filename>Settings.yaml</filename>:</para>

      <programlisting language="yaml">FLOW3:
  resource:
    publishing:
      fileSystem:
        # Strategy for mirroring files: Either "copy" or "link"
        mirrorMode: link</programlisting>
    </section>
  </section>

  <section>
    <title>Resource Stream Wrapper</title>

    <para>Static resources are often used by packages internally. Typical use
    cases are templates, XML, YAML or other data files and images for further
    processing. You might be tempted to refer to these files by using one of
    the <constant>FLOW3_PATH_*</constant> constants or by creating a path
    relative to your package. A much better and more convenient way is using
    FLOW3's built-in stream package resources wrapper.</para>

    <para>The following example reads the content of the file
    <filename>MyPackage/Resources/Private/Templates/SomeTemplate.html</filename>
    into a variable:</para>

    <example>
      <title>Accessing static resources</title>

      <programlisting language="php">$template = file_get_contents('resource://MyPackage/Private/Templates/SomeTemplate.html');</programlisting>
    </example>

    <para>Likewise you might get into a situation where you need to
    programmatically access persistent resources. The resource stream wrapper
    also supports these, all you need to do is passing the resource hash as
    the URI host:</para>

    <example>
      <title>Accessing persisted resources</title>

      <programlisting language="php">$imageFile = file_get_contents('resource://' . $resource);</programlisting>
    </example>

    <para>Note that you need to have a <classname>Resource</classname> object
    in order to access its file and that the above example only works because
    <classname>Resource</classname> provides a
    <methodname>__toString()</methodname> method which returns the resource's
    hash.</para>

    <para>You are encouraged to use this stream wrapper wherever you need to
    access a static or persisted resource in your PHP code.</para>
  </section>
</chapter>
